<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/06/20/Docker%E6%8C%87%E5%8D%97/"/>
      <url>/2023/06/20/Docker%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="Docker-指南"><a href="#Docker-指南" class="headerlink" title="Docker 指南"></a>Docker 指南</h1><h3 id="Docker-是什么？"><a href="#Docker-是什么？" class="headerlink" title="Docker 是什么？"></a>Docker 是什么？</h3><p>Docker 是一个开源的容器化平台，可以轻松地创建、部署和运行应用程序。Docker 可以将应用程序和其依赖项打包到一个容器中，使其可以在任何地方运行，保证应用程序的一致性和可移植性。</p><h3 id="Docker结构"><a href="#Docker结构" class="headerlink" title="Docker结构"></a>Docker结构</h3><p>Docker CS结构,宿主机客户端通过守护进程跟server进行通信。client发送docker命令到守护进程来管理容器和镜像。</p><p><strong>Docker 三大概念:</strong></p><ul><li>Docker 容器是 Docker 镜像的实例，容器可以被启动、停止、删除等。</li><li>Docker 镜像是用于创建 Docker 容器的模板，镜像可以被构建、修改、推送、拉取等。</li><li>Docker 仓库是用于存储和共享 Docker 镜像的中央存储库，仓库可以被创建、访问、搜索、拉取、推送等。</li></ul><hr><h3 id="镜像构成"><a href="#镜像构成" class="headerlink" title="镜像构成"></a>镜像构成</h3><p>Docker 镜像是由多个文件系统（也称为镜像层）以联合文件系统（UnionFS）的方式联合在一起构成的。每个镜像层都包含了一个文件系统的完整或部分内容，并且每个镜像层都可以看作是一个 Docker 镜像的一部分。</p><h4 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构"></a>镜像结构</h4><ul><li><p>基础镜像层：这是一个空白的镜像层，通常是由操作系统提供的。它包含了一个最小的文件系统和一些基本的工具，例如 shell 和包管理器。</p></li><li><p>应用镜像层：这是应用程序的镜像层，包含了应用程序的运行时环境和依赖的库文件等。</p></li><li><p>数据镜像层：这是一个可选的镜像层，用来存储应用程序需要的数据，例如配置文件、日志文件、数据库文件等。</p></li></ul><h4 id="镜像叠加"><a href="#镜像叠加" class="headerlink" title="镜像叠加"></a>镜像叠加</h4><p>在 Docker 构建镜像的过程中，每个镜像层都是只读的，因此任何对镜像层的修改都会被保存为一个新的镜像层。这种存储方式被称为镜像层叠加，也就是每个镜像层都是基于前一个镜像层构建的。<br>这种镜像层叠加的方式带来了多种好处，例如：</p><ul><li>镜像层之间的共享可以减少磁盘使用空间和镜像的构建时间。</li><li>镜像层之间的区别可以方便地进行版本控制和管理。</li><li>用户可以使用相同的基础镜像层来构建不同的应用程序镜像，从而提高了镜像的重用性和可维护性。</li></ul><hr><h3 id="容器介绍"><a href="#容器介绍" class="headerlink" title="容器介绍"></a>容器介绍</h3><p>Docker 容器是 Docker 技术中的一个重要概念，它是 Docker 镜像的一个可运行实例。Docker 容器包含了运行应用程序所需的所有文件系统、库文件、配置文件和依赖项等资源，以及运行应用程序的进程。Docker 容器可以看作是一个轻量级的虚拟机，它提供了一个隔离的运行环境，使得应用程序能够在不同的环境中保持一致的运行状态。与传统的虚拟机不同，Docker 容器不需要模拟硬件，因此启动和停止容器的速度非常快，通常只需要几秒钟的时间。</p><h4 id="容器的特点"><a href="#容器的特点" class="headerlink" title="容器的特点"></a>容器的特点</h4><ol><li><p>轻量级：Docker 容器只包含了应用程序运行所需的最小资源，因此非常轻量级，启动和停止速度非常快。</p></li><li><p>隔离性：Docker 容器提供了一个隔离的运行环境，使得应用程序可以在不同的环境中保持一致的运行状态，避免了应用程序之间的冲突和干扰。</p></li><li><p>可移植性：Docker 容器可以在不同的主机和操作系统上运行，使得应用程序可以在不同的环境中保持一致的运行状态，方便了应用程序的部署和迁移。</p></li><li><p>可重复性：Docker 容器可以通过 Dockerfile 和镜像的方式进行构建，使得应用程序可以在不同的环境中以相同的方式进行构建和部署，增强了应用程序的可重复性和可维护性。</p></li></ol><h3 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h3><p>Docker 仓库是一个用于存储、管理和分享 Docker 镜像的中央存储库。Docker 官方提供了一个公共仓库 Docker Hub，用户可以在 Docker Hub 上搜索、下载和分享 Docker 镜像。此外，用户也可以自己搭建 Docker 仓库，用于存储和管理自己的 Docker 镜像。</p><hr><h3 id="镜像操作"><a href="#镜像操作" class="headerlink" title="镜像操作"></a>镜像操作</h3><ul><li>docker images<br>该命令用于列出本地已经下载的 Docker 镜像，并显示它们的名称、标签、镜像 ID、大小和创建时间等信息。例如：<pre class="line-numbers language-none"><code class="language-none">$ docker imagesREPOSITORY          TAG                 IMAGE ID            CREATED             SIZEubuntu              18.04               4e2eef94cd6b        2 weeks ago         63.2MBnginx               latest              4bb46517cacd        3 weeks ago         133MB<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>docker search<br>该命令用于在 Docker Hub 上搜索 Docker 镜像，并显示它们的名称、描述、星级和官方&#x2F;非官方标识等信息。例如：</li></ul><pre class="line-numbers language-none"><code class="language-none">$ docker search nginxNAME                             DESCRIPTION                                     STARS               OFFICIAL            AUTOMATEDnginx                            Official build of Nginx.                        15199               jwilder&#x2F;nginx-proxy             Automated Nginx reverse proxy for docker con...   1377                                    ...<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>docker pull<br>该命令用于从 Docker Hub 上下载指定的 Docker 镜像，并将其保存到本地的 Docker 镜像库中。例如：</li></ul><pre class="line-numbers language-none"><code class="language-none">$ docker pull nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>docker build<br>该命令用于根据指定的 Dockerfile 文件构建一个 Docker 镜像，并将其命名为指定的名称。例如：</li></ul><pre class="line-numbers language-none"><code class="language-none">$ docker build -t my-nginx . # dockerfile 目录<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>docker rmi<br>该命令用于删除本地已经下载的指定的 Docker 镜像。例如：<pre class="line-numbers language-none"><code class="language-none">$ docker rmi my-nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><ul><li>docker run<br>该命令用于创建并启动一个 Docker 容器。<br>常用选项：<br><code>-d</code> 守护式启动(后台启动)容器<br><code>-it</code> 交互式容器<br><code>-i</code> 以交互模式运行容器，通常与-t同时使用<br><code>-t</code> 为容器重新分配一个伪终端，通常与-i同时使用<br><code>--name</code> 为容器指定名称<br><code>-p</code> 指定端口 docker端口:应用端口<br><code>-P</code> 随机分配 应用端口是应用默认端口<br><code>-v</code>：将主机上的目录挂载到容器内部的目录。<br><code>--env</code>：设置容器内部的环境变量</li></ul><p>前台方式运行容器：</p><pre class="line-numbers language-none"><code class="language-none">docker run -d --name nginx -p 8080:80 nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>守护式运行容器：</p><pre class="line-numbers language-none"><code class="language-none">docker run -d --name nginx -p 8080:80 nginx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>docker ps<br>该命令用于查看docker运行进程,默认显示当前正在运行的<br>常用选项:<br><code>-a</code> 列出当前所有正在运行的容器+历史上运行过的<br><code>-l</code>显示最近创建的容器<br><code>-n</code> 显示最近n个创建的容器<br><code>-q</code> 静默模式，只显示容器编号<br><code>--no-trunc</code> 不截断输出 说明</li></ul><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">docker ps -a<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>docker start<br>该命令用于启动已存在的容器。例如:</p><pre class="line-numbers language-none"><code class="language-none">docker start nginx # 容器id或name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>docker restart<br>该命令用于重启容器。例如:</p><pre class="line-numbers language-none"><code class="language-none">docker restart nginx # 容器id或name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>docker stop<br>该命令用于停止容器。例如:</p><pre class="line-numbers language-none"><code class="language-none">docker stop nginx # 容器id或name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>docker kill<br>该命令用于强制停止容器。例如:</p><pre class="line-numbers language-none"><code class="language-none">docker kill nginx # 容器id或name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>docker rm<br>该命令用于删除已停止的容器。例如:</p><pre class="line-numbers language-none"><code class="language-none">docker rm nginx # 容器id或name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>docker logs<br>常用选项:<br><code>-t</code> 加入时间戳<br><code>-f</code>  跟随最新的日志打印<br><code>--tail</code>  数字 显示最后多少条</p></li></ul><p>该命令用于查看容器日志。例如:</p><pre class="line-numbers language-none"><code class="language-none">docker logs -f nginx # 容器id或name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li><p>docker top<br>该命令用于查看容器内的进程。例如:</p><pre class="line-numbers language-none"><code class="language-none">docker top nginx # 容器id或name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>docker inspect<br>该命令用于查看容器详细信息。例如:</p><pre class="line-numbers language-none"><code class="language-none">docker inspect nginx # 容器id或name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>docker attach<br>该命令用于直接进入容器启动命令的终端，不会启动新的进程</p><pre class="line-numbers language-none"><code class="language-none">docker attach nginx &#x2F;bin&#x2F;bash # 容器id或name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>docker exec<br>该命令用于远程对容器执行操作。例如:</p><pre class="line-numbers language-none"><code class="language-none">docker exec my-nginx ls # 容器id或name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>docker cp<br>该命令用于拷贝容器内文件到宿主机 。例如:</p><pre class="line-numbers language-none"><code class="language-none">docker cp my-nginx:&#x2F;usr&#x2F;share&#x2F;nginx&#x2F;html&#x2F;index.html &#x2F;path&#x2F;on&#x2F;host # 容器id或name<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ul><hr><h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><p>主要是数据共享 数据持久化</p><ul><li>特点：</li></ul><ol><li>数据卷可以在容器之间共享或重用数据</li><li>数据卷中的更改可以直接生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ol><ul><li>命令行添加数据卷:</li></ul><ol><li><p>使用 <code>-v</code> 参数添加数据卷到容器中的示例命令：</p><pre class="line-numbers language-none"><code class="language-none">docker run -d -v &#x2F;mydata:&#x2F;data my-image<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>使用 <code>--mount</code> 参数添加数据卷到容器中的示例命令：</p></li></ol><pre class="line-numbers language-none"><code class="language-none">docker run -d --mount source&#x3D;myvol,target&#x3D;&#x2F;data my-image<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是，如果使用 <code>-v</code> 参数添加数据卷，则可以直接指定本地主机上的目录作为数据卷，但是如果使用 <code>--mount</code> 参数添加数据卷，则需要先创建数据卷，然后将其映射到容器内部的目录中。可以使用 <code>docker volume create</code> 命令来创建数据卷，例如：</p><pre class="line-numbers language-none"><code class="language-none">docker volume create myvol<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ul><li>Dockerfile添加数据卷:</li></ul><pre class="line-numbers language-none"><code class="language-none">VOLUME [&quot;&#x2F;dataVolumeContainer01&quot;,&quot;&#x2F;data&#x2F;VolumeContainer2&quot;]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>需要注意的是Dockerfile添加<code>volume</code>指令只支持容器,不支持宿主机docker挂载主机目录。<br>容器访问出现cannot open directory:Permission denied需要在挂载目录时添加<code>--privileged=true</code>参数(对容器访问主机设备授权) </p><h4 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h4><p>数据卷容器是一个命名的容器数据卷，其他容器通过挂载这个(父容器)实现数据共享,挂载数据卷的容器,称之为数据卷容器</p><ul><li><p>容器间传递共享  (–volumes-from)  例如 dc02 继承 dco1:</p><pre class="line-numbers language-none"><code class="language-none">docker run -it --name dco2 --volumes-from dc01 zzyy&#x2F;centos<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>数据卷容器容灾:</p></li><li><p>dco2 dc03 都继承dc01 删除dc01后 | dco2 dc03 数据卷文件还在吗？<br>do2&#x2F;do3数据卷文件还存在,因为容器之间配置信息的传递,数据卷的生命周期一直持续到没有容器使用它为止。</p></li></ul><hr><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile是用来构建Docker镜像的构建文件,是由一系列命令和参数构成的脚本。如果Docker镜像是软件的交付品，Docker容器是软件的运行态，Dockerfile则可以认为是软件的原材料。Dockerfile面向开发 Docker镜像成为交付标准 Docker容器涉及部署与运维。三者缺一不可,合力充当Docker体系的基石</p><ul><li>Dockerfile 语法格式</li></ul><ol><li>每条保留字指令都必须为大写字母且后面要跟随至少一个参数</li><li>指令按照从上到下，顺序执行</li><li>#表示注释</li><li>每条指令都会创建一个新的镜像层,并对镜像进行提交</li></ol><ul><li>Dockerfile的解析执行过程</li></ul><ol><li>docker从基础镜像运行一个容器</li><li>执行一条指令并对容器做出修改</li><li>执行类似docker commit的操作提交一个新的镜像层</li><li>docker 再基于刚提交的镜像运行一个新容器</li><li>执行dockerfile的下一条指令直到所有指令都执行完成</li></ol><ul><li><p>Dockerfile 体系结构</p><pre class="line-numbers language-none"><code class="language-none">FROM --基础镜像MAINTAINER --镜像维护者的姓名和邮箱RUN --容器构建时需要运行的命令EXPOSE --当前容器应用对外暴露的端口WORKDIR --指定创建容器后,终端默认登录进来的工作目录ENV --用户构建镜像过程中设置环境变量ADD --将宿主机目录下的文件拷贝进镜像| ADD命令会自动处理URL和解压缩COPY --类似ADD,拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件&#x2F;目录复制到新的一层镜像内的&lt;目标路径&gt;位置。两种写法:1.COPY src dest2.COPY [&quot;src&quot;,&quot;dest&quot;]VOLUME --容器数据卷,用于数据保存和持久化工作CMD --指定一个容器启动时要运行的命令。Dockerfile中可以有多个CMD指令。但只有最后一个生效,CMD会被docker run 之后的参数替换ENTRYPOINT --指定一个容器启动时要运行的命令。ENTPRPOINT的目的和CMD一样,都是在指定容器启动程序及参数ONBUILD --当构建一个被继承的Dockerfile时运行命令,父镜像在被字镜像继承后父镜像的onbuild被触发<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li><p>Dockerfile</p></li></ul><p>示例：</p><pre class="line-numbers language-none"><code class="language-none"># 指定基础镜像FROM ubuntu:20.04# 设置工作目录WORKDIR &#x2F;app# 添加文件到镜像中COPY . &#x2F;app# 运行命令RUN apt-get update &amp;&amp; \    apt-get install -y nginx &amp;&amp; \    apt-get clean &amp;&amp; \    rm -rf &#x2F;var&#x2F;lib&#x2F;apt&#x2F;lists&#x2F;*# 暴露端口EXPOSE 80# 设置环境变量ENV APP_NAME myapp# 设置启动命令CMD [ &quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot; ]<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><hr>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/06/10/hello-world/"/>
      <url>/2023/06/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello World</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2023/05/21/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/05/21/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
