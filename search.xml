<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Docker指南</title>
      <link href="/2023/06/18/Docker%E6%8C%87%E5%8D%97/"/>
      <url>/2023/06/18/Docker%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h3 id="Docker-是什么？"><a href="#Docker-是什么？" class="headerlink" title="Docker 是什么？"></a>Docker 是什么？</h3><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;Docker 是一个开源的容器化平台，可以轻松地创建、部署和运行应用程序。Docker 可以将应用程序和其依赖项打包到一个容器中，使其可以在任何地方运行，保证应用程序的一致性和可移植性。</p><h3 id="Docker结构"><a href="#Docker结构" class="headerlink" title="Docker结构:"></a>Docker结构:</h3><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; Docker CS结构,宿主机客户端通过守护进程跟server进行通信。client发送docker命令到守护进程来管理容器和镜像。</p><h3 id="Docker-三大概念"><a href="#Docker-三大概念" class="headerlink" title="Docker 三大概念:"></a>Docker 三大概念:</h3><ul><li>Docker 容器是 Docker 镜像的实例，容器可以被启动、停止、删除等。</li><li>Docker 镜像是用于创建 Docker 容器的模板，镜像可以被构建、修改、推送、拉取等。</li><li>Docker 仓库是用于存储和共享 Docker 镜像的中央存储库，仓库可以被创建、访问、搜索、拉取、推送等。</li></ul><h3 id="镜像构成"><a href="#镜像构成" class="headerlink" title="镜像构成:"></a>镜像构成:</h3><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;Docker 镜像是由多个文件系统（也称为镜像层）以联合文件系统（UnionFS）的方式联合在一起构成的。每个镜像层都包含了一个文件系统的完整或部分内容，并且每个镜像层都可以看作是一个 Docker 镜像的一部分。</p><h3 id="镜像结构"><a href="#镜像结构" class="headerlink" title="镜像结构:"></a>镜像结构:</h3><ul><li><p>基础镜像层：这是一个空白的镜像层，通常是由操作系统提供的。它包含了一个最小的文件系统和一些基本的工具，例如 shell 和包管理器。</p></li><li><p>应用镜像层：这是应用程序的镜像层，包含了应用程序的运行时环境和依赖的库文件等。</p></li><li><p>数据镜像层：这是一个可选的镜像层，用来存储应用程序需要的数据，例如配置文件、日志文件、数据库文件等。</p></li></ul><h3 id="镜像叠加"><a href="#镜像叠加" class="headerlink" title="镜像叠加:"></a>镜像叠加:</h3><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;在 Docker 构建镜像的过程中，每个镜像层都是只读的，因此任何对镜像层的修改都会被保存为一个新的镜像层。这种存储方式被称为镜像层叠加，也就是每个镜像层都是基于前一个镜像层构建的。<br>这种镜像层叠加的方式带来了多种好处，例如：</p><ul><li>镜像层之间的共享可以减少磁盘使用空间和镜像的构建时间。</li><li>镜像层之间的区别可以方便地进行版本控制和管理。</li><li>用户可以使用相同的基础镜像层来构建不同的应用程序镜像，从而提高了镜像的重用性和可维护性。</li></ul><h3 id="容器介绍"><a href="#容器介绍" class="headerlink" title="容器介绍"></a>容器介绍</h3><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;Docker 容器是 Docker 技术中的一个重要概念，它是 Docker 镜像的一个可运行实例。Docker 容器包含了运行应用程序所需的所有文件系统、库文件、配置文件和依赖项等资源，以及运行应用程序的进程。Docker 容器可以看作是一个轻量级的虚拟机，它提供了一个隔离的运行环境，使得应用程序能够在不同的环境中保持一致的运行状态。与传统的虚拟机不同，Docker 容器不需要模拟硬件，因此启动和停止容器的速度非常快，通常只需要几秒钟的时间。</p><h3 id="容器的特点"><a href="#容器的特点" class="headerlink" title="容器的特点:"></a>容器的特点:</h3><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;1. 轻量级：Docker 容器只包含了应用程序运行所需的最小资源，因此非常轻量级，启动和停止速度非常快。</p><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;2. 隔离性：Docker 容器提供了一个隔离的运行环境，使得应用程序可以在不同的环境中保持一致的运行状态，避免了应用程序之间的冲突和干扰。</p><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;3. 可移植性：Docker 容器可以在不同的主机和操作系统上运行，使得应用程序可以在不同的环境中保持一致的运行状态，方便了应用程序的部署和迁移。</p><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;4. 可重复性：Docker 容器可以通过 Dockerfile 和镜像的方式进行构建，使得应用程序可以在不同的环境中以相同的方式进行构建和部署，增强了应用程序的可重复性和可维护性。</p><h3 id="Docker仓库"><a href="#Docker仓库" class="headerlink" title="Docker仓库"></a>Docker仓库</h3><p>&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;Docker 仓库是一个用于存储、管理和分享 Docker 镜像的中央存储库。Docker 官方提供了一个公共仓库 Docker Hub，用户可以在 Docker Hub 上搜索、下载和分享 Docker 镜像。此外，用户也可以自己搭建 Docker 仓库，用于存储和管理自己的 Docker 镜像。</p><h3 id="镜像操作："><a href="#镜像操作：" class="headerlink" title="镜像操作："></a>镜像操作：</h3><ul><li>docker images<br>该命令用于列出本地已经下载的 Docker 镜像，并显示它们的名称、标签、镜像 ID、大小和创建时间等信息。例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker images</span><br><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              18.04               4e2eef94cd6b        2 weeks ago         63.2MB</span><br><span class="line">nginx               latest              4bb46517cacd        3 weeks ago         133MB</span><br></pre></td></tr></table></figure></li><li>docker search<br>该命令用于在 Docker Hub 上搜索 Docker 镜像，并显示它们的名称、描述、星级和官方&#x2F;非官方标识等信息。例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker search nginx</span><br><span class="line">NAME                             DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">nginx                            Official build of Nginx.                        15199               </span><br><span class="line">jwilder/nginx-proxy             Automated Nginx reverse proxy for docker con...   1377                                    </span><br><span class="line">...</span><br></pre></td></tr></table></figure><ul><li>docker pull<br>该命令用于从 Docker Hub 上下载指定的 Docker 镜像，并将其保存到本地的 Docker 镜像库中。例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull nginx</span><br></pre></td></tr></table></figure><ul><li>docker build<br>该命令用于根据指定的 Dockerfile 文件构建一个 Docker 镜像，并将其命名为指定的名称。例如：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t my-nginx . # dockerfile 目录</span><br></pre></td></tr></table></figure><ul><li>docker rmi<br>该命令用于删除本地已经下载的指定的 Docker 镜像。例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rmi my-nginx</span><br></pre></td></tr></table></figure></li></ul><h3 id="容器操作"><a href="#容器操作" class="headerlink" title="容器操作"></a>容器操作</h3><ul><li>docker run<br>该命令用于创建并启动一个 Docker 容器。<br>常用选项：<br> <code>-d</code> 守护式启动(后台启动)容器<br> <code>-it</code> 交互式容器<br> <code>-i</code> 以交互模式运行容器，通常与-t同时使用<br> <code>-t</code> 为容器重新分配一个伪终端，通常与-i同时使用<br> <code>--name</code> 为容器指定名称<br> <code>-p</code> 指定端口 docker端口:应用端口<br> <code>-P</code> 随机分配 应用端口是应用默认端口<br> <code>-v</code>：将主机上的目录挂载到容器内部的目录。<br> <code>--env</code>：设置容器内部的环境变量</li></ul><p>&amp;emsp;&amp;emsp;前台方式运行容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx -p 8080:80 nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>&amp;emsp;&amp;emsp;守护式运行容器：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name nginx -p 8080:80 nginx</span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li>docker ps<br>该命令用于查看docker运行进程,默认显示当前正在运行的<br> 常用选项:<br> <code>-a</code> 列出当前所有正在运行的容器+历史上运行过的<br> <code>-l</code>显示最近创建的容器<br> <code>-n</code> 显示最近n个创建的容器<br> <code>-q</code> 静默模式，只显示容器编号<br> <code>--no-trunc</code> 不截断输出 说明</li></ul><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><ul><li><p>docker start<br>  该命令用于启动已存在的容器。例如:<br> <code>docker start nginx # 容器id或name</code></p></li><li><p>docker restart<br>该命令用于重启容器。例如:<br> <code>docker restart nginx # 容器id或name</code></p></li><li><p>docker stop<br> 该命令用于停止容器。例如:<br> <code>docker stop nginx # 容器id或name </code></p></li><li><p>docker kill<br>该命令用于强制停止容器。例如:<br> <code>docker kill nginx # 容器id或name</code></p></li><li><p>docker rm<br> 该命令用于删除已停止的容器。例如:<br> <code>docker rm nginx # 容器id或name</code></p></li><li><p>docker logs<br>常用选项:<br> <code>-t</code> 加入时间戳<br> <code>-f</code>  跟随最新的日志打印<br> <code>--tail</code>  数字 显示最后多少条<br> 该命令用于查看容器日志。例如:<br> <code>docker logs -f nginx # 容器id或name</code></p></li><li><p>docker top<br> 该命令用于查看容器内的进程。例如:<br> <code>docker top nginx # 容器id或name</code></p></li><li><p>docker inspect<br>该命令用于查看容器详细信息。例如:<br> <code>docker inspect nginx # 容器id或name</code></p></li><li><p>docker attach<br> 该命令用于直接进入容器启动命令的终端，不会启动新的进程<br> <code>docker attach nginx /bin/bash # 容器id或name</code></p></li><li><p>docker exec<br> 该命令用于远程对容器执行操作。例如:<br> <code>docker exec my-nginx ls # 容器id或name</code></p></li><li><p>docker cp<br> 该命令用于拷贝容器内文件到宿主机 。例如:</p></li></ul><p><code>docker cp my-nginx:/usr/share/nginx/html/index.html /path/on/host # 容器id或name</code></p><h3 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h3><p>&amp;emsp;主要是数据共享 数据持久化</p><ul><li><p>特点：</p><ol><li>数据卷可以在容器之间共享或重用数据</li><li>数据卷中的更改可以直接生效</li><li>数据卷中的更改不会包含在镜像的更新中</li><li>数据卷的生命周期一直持续到没有容器使用它为止</li></ol></li><li><p>命令行添加数据卷:</p><ol><li><p>使用 <code>-v</code> 参数添加数据卷到容器中的示例命令：</p><p><code>docker run -d -v /mydata:/data my-image</code></p></li><li><p>使用 <code>--mount</code> 参数添加数据卷到容器中的示例命令：</p><p> <code>docker run -d --mount source=myvol,target=/data my-image</code></p></li></ol><p> &amp;emsp;&amp;emsp;需要注意的是，如果使用 <code>-v</code> 参数添加数据卷，则可以直接指定本地主机上的目录作为数据卷，但是如果使用 <code>--mount</code> 参数添加数据卷，则需要先创建数据卷，然后将其映射到容器内部的目录中。可以使用 <code>docker volume create</code> 命令来创建数据卷，例如：</p></li></ul><p><code>docker volume create myvol</code></p><ul><li><p>Dockerfile添加数据卷:</p><pre><code> ``` VOLUME [&quot;/dataVolumeContainer01&quot;,&quot;/data/VolumeContainer2&quot;]```</code></pre><p> &amp;emsp;&amp;emsp;需要注意的是Dockerfile添加<code>volume</code>指令只支持容器,不支持宿主机docker挂载主机目录。<br> 容器访问出现cannot open directory:Permission denied需要在挂载目录时添加 –privileged&#x3D;true参数(对容器访问主机设备授权)</p></li></ul><h3 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h3><p> &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;数据卷容器是一个命名的容器数据卷，其他容器通过挂载这个(父容器)实现数据共享,挂载数据卷的容器,称之为数据卷容器</p><ul><li><p>容器间传递共享  (–volumes-from)  例如 dc02 继承 dco1:<br>  <code>docker run -it --name dco2 --volumes-from dc01 zzyy/centos </code></p></li><li><p>数据卷容器容灾:</p><ul><li>dco2 dc03 都继承dc01 删除dc01后 | dco2 dc03 数据卷文件还在吗？<br> &amp;emsp;&amp;emsp;do2&#x2F;do3数据卷文件还存在,因为容器之间配置信息的传递,数据卷的生命周期一直持续到没有容器使用它为止。</li></ul></li></ul><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p> &amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp; Dockerfile是用来构建Docker镜像的构建文件,是由一系列命令和参数构成的脚本。如果Docker镜像是软件的交付品，Docker容器是软件的运行态，Dockerfile则可以认为是软件的原材料。Dockerfile面向开发 Docker镜像成为交付标准 Docker容器涉及部署与运维。三者缺一不可,合力充当Docker体系的基石</p><ul><li><p>Dockerfile 语法格式<br> &amp;emsp;&amp;emsp;1. 每条保留字指令都必须为大写字母且后面要跟随至少一个参数<br> &amp;emsp;&amp;emsp;2. 指令按照从上到下，顺序执行<br> &amp;emsp;&amp;emsp;3. #表示注释<br> &amp;emsp;&amp;emsp;4. 每条指令都会创建一个新的镜像层,并对镜像进行提交</p></li><li><p>Dockerfile的解析执行过程<br> &amp;emsp;&amp;emsp;1. docker从基础镜像运行一个容器<br> &amp;emsp;&amp;emsp;2. 执行一条指令并对容器做出修改<br> &amp;emsp;&amp;emsp;3. 执行类似docker commit的操作提交一个新的镜像层<br> &amp;emsp;&amp;emsp;4. docker 再基于刚提交的镜像运行一个新容器<br> &amp;emsp;&amp;emsp;5. 执行dockerfile的下一条指令直到所有指令都执行完成 </p></li><li><p>Dockerfile 体系结构</p> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">FROM --基础镜像</span><br><span class="line">MAINTAINER --镜像维护者的姓名和邮箱</span><br><span class="line">RUN --容器构建时需要运行的命令</span><br><span class="line">EXPOSE --当前容器应用对外暴露的端口</span><br><span class="line">WORKDIR --指定创建容器后,终端默认登录进来的工作目录</span><br><span class="line">ENV --用户构建镜像过程中设置环境变量</span><br><span class="line">ADD --将宿主机目录下的文件拷贝进镜像| ADD命令会自动处理URL和解压缩</span><br><span class="line">COPY --类似ADD,拷贝文件和目录到镜像中。将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层镜像内的&lt;目标路径&gt;位置。两种写法:</span><br><span class="line">1.COPY src dest</span><br><span class="line">2.COPY [&quot;src&quot;,&quot;dest&quot;]</span><br><span class="line">VOLUME --容器数据卷,用于数据保存和持久化工作</span><br><span class="line">CMD --指定一个容器启动时要运行的命令。Dockerfile中可以有多个CMD指令。但只有最后一个生效,CMD会被docker run 之后的参数替换</span><br><span class="line">ENTRYPOINT --指定一个容器启动时要运行的命令。ENTPRPOINT的目的和CMD一样,都是在指定容器启动程序及参数</span><br><span class="line">ONBUILD --当构建一个被继承的Dockerfile时运行命令,父镜像在被字镜像继承后父镜像的onbuild被触发</span><br></pre></td></tr></table></figure></li><li><p>Dockerfile</p></li></ul><p> 示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># 指定基础镜像</span><br><span class="line">FROM ubuntu:20.04</span><br><span class="line"></span><br><span class="line"># 设置工作目录</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># 添加文件到镜像中</span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line"># 运行命令</span><br><span class="line">RUN apt-get update &amp;&amp; \</span><br><span class="line">    apt-get install -y nginx &amp;&amp; \</span><br><span class="line">    apt-get clean &amp;&amp; \</span><br><span class="line">    rm -rf /var/lib/apt/lists/*</span><br><span class="line"></span><br><span class="line"># 暴露端口</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># 设置环境变量</span><br><span class="line">ENV APP_NAME myapp</span><br><span class="line"></span><br><span class="line"># 设置启动命令</span><br><span class="line">CMD [ &quot;nginx&quot;, &quot;-g&quot;, &quot;daemon off;&quot; ]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 容器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/2023/06/10/hello-world/"/>
      <url>/2023/06/10/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Hello World</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>第一篇博客</title>
      <link href="/2023/05/21/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2023/05/21/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
